<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>整合限流策略 | Joohwan</title><meta name="author" content="Joohwan."><meta name="copyright" content="Joohwan."><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="整合限流策略限流 限流又称为流量控制（流控），通常是指限制到达系统的并发请求数  常用的限流策略漏桶法 漏桶法限流很好理解，假设我们有一个水桶按固定的速率向下方滴落一滴水，无论有多少请求，请求的速率有多大，都按照固定的速率流出，对应到系统中就是按照固定的速率处理请求  uber-go&#x2F;ratelimit实现 uber-go&#x2F;ratelimit  Example uber-go&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="整合限流策略">
<meta property="og:url" content="https://piwriw.github.io/2023/03/02/web/go/%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5/index.html">
<meta property="og:site_name" content="Joohwan">
<meta property="og:description" content="整合限流策略限流 限流又称为流量控制（流控），通常是指限制到达系统的并发请求数  常用的限流策略漏桶法 漏桶法限流很好理解，假设我们有一个水桶按固定的速率向下方滴落一滴水，无论有多少请求，请求的速率有多大，都按照固定的速率流出，对应到系统中就是按照固定的速率处理请求  uber-go&#x2F;ratelimit实现 uber-go&#x2F;ratelimit  Example uber-go&amp;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://piwriw.github.io/img/go.png">
<meta property="article:published_time" content="2023-03-02T04:32:58.000Z">
<meta property="article:modified_time" content="2025-08-24T14:17:08.279Z">
<meta property="article:author" content="Joohwan.">
<meta property="article:tag" content="web">
<meta property="article:tag" content="go">
<meta property="article:tag" content="限流策略">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://piwriw.github.io/img/go.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "整合限流策略",
  "url": "https://piwriw.github.io/2023/03/02/web/go/%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5/",
  "image": "https://piwriw.github.io/img/go.png",
  "datePublished": "2023-03-02T04:32:58.000Z",
  "dateModified": "2025-08-24T14:17:08.279Z",
  "author": [
    {
      "@type": "Person",
      "name": "Joohwan.",
      "url": "https://github.com/Piwriw"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://piwriw.github.io/2023/03/02/web/go/%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '整合限流策略',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="/js/welcome.js"></script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">245</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">59</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fas fa-folder-open"></i><span> 文章统计</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/wish/"><i class="fa-fw fas fa-tags"></i><span> 许愿墙</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/go.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Joohwan</span></a><a class="nav-page-title" href="/"><span class="site-name">整合限流策略</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fas fa-folder-open"></i><span> 文章统计</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/wish/"><i class="fa-fw fas fa-tags"></i><span> 许愿墙</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">整合限流策略</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-02T04:32:58.000Z" title="发表于 2023-03-02 12:32:58">2023-03-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-24T14:17:08.279Z" title="更新于 2025-08-24 22:17:08">2025-08-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/web/">web</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>5分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-08-24 22:17:08&quot;}" hidden></div><h1 id="整合限流策略"><a href="#整合限流策略" class="headerlink" title="整合限流策略"></a>整合限流策略</h1><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><ul>
<li>限流又称为流量控制（流控），通常是指限制到达系统的并发请求数</li>
</ul>
<h2 id="常用的限流策略"><a href="#常用的限流策略" class="headerlink" title="常用的限流策略"></a>常用的限流策略</h2><h3 id="漏桶法"><a href="#漏桶法" class="headerlink" title="漏桶法"></a>漏桶法</h3><ul>
<li>漏桶法限流很好理解，假设我们有一个水桶按固定的速率向下方滴落一滴水，无论有多少请求，请求的速率有多大，都按照固定的速率流出，对应到系统中就是按照固定的速率处理请求</li>
</ul>
<h4 id="uber-go-ratelimit实现"><a href="#uber-go-ratelimit实现" class="headerlink" title="uber-go&#x2F;ratelimit实现"></a>uber-go&#x2F;ratelimit实现</h4><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/uber-go/ratelimit">uber-go&#x2F;ratelimit</a></li>
</ul>
<h4 id="Example-uber-go-ratelimit"><a href="#Example-uber-go-ratelimit" class="headerlink" title="Example uber-go&#x2F;ratelimit"></a>Example uber-go&#x2F;ratelimit</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 漏桶法</span></span><br><span class="line"><span class="comment">// 定义全局限流器对象</span></span><br><span class="line"><span class="keyword">var</span> rateLimit ratelimit.Limiter</span><br><span class="line"><span class="comment">// 在 gin.HandlerFunc 加入限流逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">leakyBucket</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">	prev := time.Now()</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		now := rateLimit.Take()</span><br><span class="line">		fmt.Println(now.Sub(prev)) <span class="comment">// 为了打印时间间隔</span></span><br><span class="line">		prev = now <span class="comment">// 记录上一次的时间，没有这个打印的会有问题</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rateLimit = ratelimit.New(<span class="number">10</span>)</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/ping&quot;</span>, leakyBucket(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(<span class="number">200</span>, <span class="literal">true</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run() <span class="comment">// listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type limiter struct &#123;</span></span><br><span class="line"><span class="comment">// 	sync.Mutex                // 锁</span></span><br><span class="line"><span class="comment">// 	last       time.Time      // 上一次的时刻</span></span><br><span class="line"><span class="comment">// 	sleepFor   time.Duration  // 需要等待的时间</span></span><br><span class="line"><span class="comment">// 	perRequest time.Duration  // 每次的时间间隔</span></span><br><span class="line"><span class="comment">// 	maxSlack   time.Duration  // 最大的富余量</span></span><br><span class="line"><span class="comment">// 	clock      Clock          // 时钟</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><ul>
<li>令牌桶其实和漏桶的原理类似，令牌桶就是想象有一个固定大小的桶，系统会以恒定速率向桶中放 Token，桶满则暂时不放</li>
</ul>
<h4 id="github-com-juju-ratelimit-实现"><a href="#github-com-juju-ratelimit-实现" class="headerlink" title="github.com&#x2F;juju&#x2F;ratelimit 实现"></a>github.com&#x2F;juju&#x2F;ratelimit 实现</h4><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/juju/ratelimit">github.com&#x2F;juju&#x2F;ratelimit</a></li>
<li><strong>创建令牌桶:</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建指定填充速率和容量大小的令牌桶</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBucket</span><span class="params">(fillInterval time.Duration, capacity <span class="type">int64</span>)</span></span> *Bucket</span><br><span class="line"><span class="comment">// 创建指定填充速率、容量大小和每次填充的令牌数的令牌桶</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBucketWithQuantum</span><span class="params">(fillInterval time.Duration, capacity, quantum <span class="type">int64</span>)</span></span> *Bucket</span><br><span class="line"><span class="comment">// 创建填充速度为指定速率和容量大小的令牌桶</span></span><br><span class="line"><span class="comment">// NewBucketWithRate(0.1, 200) 表示每秒填充20个令牌</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBucketWithRate</span><span class="params">(rate <span class="type">float64</span>, capacity <span class="type">int64</span>)</span></span> *Bucket</span><br></pre></td></tr></table></figure></li>
<li><strong>取出令牌:</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取token（非阻塞）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *Bucket)</span></span> Take(count <span class="type">int64</span>) time.Duration</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *Bucket)</span></span> TakeAvailable(count <span class="type">int64</span>) <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最多等maxWait时间取token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *Bucket)</span></span> TakeMaxDuration(count <span class="type">int64</span>, maxWait time.Duration) (time.Duration, <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取token（阻塞）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *Bucket)</span></span> Wait(count <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *Bucket)</span></span> WaitMaxDuration(count <span class="type">int64</span>, maxWait time.Duration) <span class="type">bool</span></span><br></pre></td></tr></table></figure></li>
<li><strong>当前令牌数 &#x3D; 上一次剩余的令牌数 + (本次取令牌的时刻-上一次取令牌的时刻)&#x2F;放置令牌的时间间隔 * 每次放置的令牌数</strong></li>
</ul>
<h4 id="Example-github-com-juju-ratelimit"><a href="#Example-github-com-juju-ratelimit" class="headerlink" title="Example github.com&#x2F;juju&#x2F;ratelimit"></a>Example github.com&#x2F;juju&#x2F;ratelimit</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&quot;github.com/juju/ratelimit&quot;</span>)</span><br><span class="line"><span class="comment">// 令牌桶方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rateLimit</span><span class="params">(fillIntrerval time.Duration,<span class="built_in">cap</span> <span class="type">int64</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(ctx.*gin.Content)</span></span>&#123;</span><br><span class="line">    rl:ratelimit.NewBucket(fillIntrerval,<span class="built_in">cap</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Content)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> rl.TakeAvailable(<span class="number">1</span>)==<span class="number">1</span>&#123;</span><br><span class="line">            c.Next()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.String(http.StatusOK,<span class="string">&quot;rate limit ......&quot;</span>)</span><br><span class="line">    c.Abort()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="固定窗口"><a href="#固定窗口" class="headerlink" title="固定窗口"></a>固定窗口</h3><ul>
<li>每开启一个新的窗口，在窗口时间大小内，可以通过窗口请求上限个请求</li>
<li>该算法主要是会存在临界问题，如果流量都集中在两个窗口的交界处，那么突发流量会是设置上限的两倍</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> limiter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FixedWindowLimiter 固定窗口限流器</span></span><br><span class="line"><span class="keyword">type</span> FixedWindowLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">   limit    <span class="type">int</span>           <span class="comment">// 窗口请求上限</span></span><br><span class="line">   window   time.Duration <span class="comment">// 窗口时间大小</span></span><br><span class="line">   counter  <span class="type">int</span>           <span class="comment">// 计数器</span></span><br><span class="line">   lastTime time.Time     <span class="comment">// 上一次请求的时间</span></span><br><span class="line">   mutex    sync.Mutex    <span class="comment">// 避免并发问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFixedWindowLimiter</span><span class="params">(limit <span class="type">int</span>, window time.Duration)</span></span> *FixedWindowLimiter &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;FixedWindowLimiter&#123;</span><br><span class="line">      limit:    limit,</span><br><span class="line">      window:   window,</span><br><span class="line">      lastTime: time.Now(),</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *FixedWindowLimiter)</span></span> TryAcquire() <span class="type">bool</span> &#123;</span><br><span class="line">   l.mutex.Lock()</span><br><span class="line">   <span class="keyword">defer</span> l.mutex.Unlock()</span><br><span class="line">   <span class="comment">// 获取当前时间</span></span><br><span class="line">   now := time.Now()</span><br><span class="line">   <span class="comment">// 如果当前窗口失效，计数器清0，开启新的窗口</span></span><br><span class="line">   <span class="keyword">if</span> now.Sub(l.lastTime) &gt; l.window &#123;</span><br><span class="line">      l.counter = <span class="number">0</span></span><br><span class="line">      l.lastTime = now</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 若到达窗口请求上限，请求失败</span></span><br><span class="line">   <span class="keyword">if</span> l.counter &gt;= l.limit &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 若没到窗口请求上限，计数器+1，请求成功</span></span><br><span class="line">   l.counter++</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ul>
<li>滑动窗口类似于固定窗口，它只是把大窗口切分成多个小窗口，每次向右移动一个小窗口，它可以避免两倍的突发流量。</li>
<li>固定窗口可以说是滑动窗口的一种特殊情况，只要滑动窗口里面的小窗口和大窗口大小一</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> limiter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;errors&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SlidingWindowLimiter 滑动窗口限流器</span></span><br><span class="line"><span class="keyword">type</span> SlidingWindowLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">   limit        <span class="type">int</span>           <span class="comment">// 窗口请求上限</span></span><br><span class="line">   window       <span class="type">int64</span>         <span class="comment">// 窗口时间大小</span></span><br><span class="line">   smallWindow  <span class="type">int64</span>         <span class="comment">// 小窗口时间大小</span></span><br><span class="line">   smallWindows <span class="type">int64</span>         <span class="comment">// 小窗口数量</span></span><br><span class="line">   counters     <span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int</span> <span class="comment">// 小窗口计数器</span></span><br><span class="line">   mutex        sync.Mutex    <span class="comment">// 避免并发问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSlidingWindowLimiter 创建滑动窗口限流器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlidingWindowLimiter</span><span class="params">(limit <span class="type">int</span>, window, smallWindow time.Duration)</span></span> (*SlidingWindowLimiter, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">// 窗口时间必须能够被小窗口时间整除</span></span><br><span class="line">   <span class="keyword">if</span> window%smallWindow != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;window cannot be split by integers&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> &amp;SlidingWindowLimiter&#123;</span><br><span class="line">      limit:        limit,</span><br><span class="line">      window:       <span class="type">int64</span>(window),</span><br><span class="line">      smallWindow:  <span class="type">int64</span>(smallWindow),</span><br><span class="line">      smallWindows: <span class="type">int64</span>(window / smallWindow),</span><br><span class="line">      counters:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int</span>),</span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *SlidingWindowLimiter)</span></span> TryAcquire() <span class="type">bool</span> &#123;</span><br><span class="line">   l.mutex.Lock()</span><br><span class="line">   <span class="keyword">defer</span> l.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取当前小窗口值</span></span><br><span class="line">   currentSmallWindow := time.Now().UnixNano() / l.smallWindow * l.smallWindow</span><br><span class="line">   <span class="comment">// 获取起始小窗口值</span></span><br><span class="line">   startSmallWindow := currentSmallWindow - l.smallWindow*(l.smallWindows<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 计算当前窗口的请求总数</span></span><br><span class="line">   <span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line">   <span class="keyword">for</span> smallWindow, counter := <span class="keyword">range</span> l.counters &#123;</span><br><span class="line">      <span class="keyword">if</span> smallWindow &lt; startSmallWindow &#123;</span><br><span class="line">         <span class="built_in">delete</span>(l.counters, smallWindow)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         count += counter</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 若到达窗口请求上限，请求失败</span></span><br><span class="line">   <span class="keyword">if</span> count &gt;= l.limit &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 若没到窗口请求上限，当前小窗口计数器+1，请求成功</span></span><br><span class="line">   l.counters[currentSmallWindow]++</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gin框架中使用限流中间件"><a href="#gin框架中使用限流中间件" class="headerlink" title="gin框架中使用限流中间件"></a>gin框架中使用限流中间件</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middlewares</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/juju/ratelimit&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 令牌桶作为限流策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RateLimitMiddleware</span><span class="params">(fillInterval time.Duration, <span class="built_in">cap</span> <span class="type">int64</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	bucket := ratelimit.NewBucket(fillInterval, <span class="built_in">cap</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 如果取不到令牌就中断本次请求返回 rate limit...</span></span><br><span class="line">		<span class="keyword">if</span> bucket.TakeAvailable(<span class="number">1</span>) &lt; <span class="number">1</span> &#123;</span><br><span class="line">			c.String(http.StatusOK, <span class="string">&quot;rate limit...&quot;</span>)</span><br><span class="line">			c.Abort()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.Next()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Piwriw">Joohwan.</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://piwriw.github.io/2023/03/02/web/go/%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5/">https://piwriw.github.io/2023/03/02/web/go/限流策略/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://piwriw.github.io" target="_blank">Joohwan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/web/">web</a><a class="post-meta__tags" href="/tags/go/">go</a><a class="post-meta__tags" href="/tags/%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5/">限流策略</a></div><div class="post-share"><div class="social-share" data-image="/img/go.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/03/02/web/go/Linux%E9%83%A8%E7%BD%B2Go/" title="Linux部署Go"><img class="cover" src="/img/go.png" onerror="onerror=null;src='/img/404.png'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux部署Go</div></div><div class="info-2"><div class="info-item-1">Linux部署Gobash一键部署bash地址 下载123456# 安装wget命令yum install -y wget# 在 ~ 下创建 go 文件夹，并进入 go 文件夹mkdir ~/go &amp;&amp; cd ~/go# 下载的 go 压缩包wget https://studygolang.com/dl/golang/go1.17.linux-amd64.tar.gz 解压1tar -C /usr/local -zxvf go1.17.0.linux-amd64.tar.gz  添加到环境变量123456vi /etc/profile# 在/etc/profile最后一行添加export GOROOT=/usr/local/goexport PATH=$PATH:$GOROOT/bin# 保存退出后source一下source /etc/profile  验证GO1go version linux上运行Gin1234# 更换代理源export GOPROXY=https://mirrors.aliyun.com/goproxy/# 开启go modexport G...</div></div></div></a><a class="pagination-related" href="/2023/03/02/web/go/%E6%95%B4%E5%90%88sql%E5%92%8Csqlx/" title="整合sql和sqlx"><img class="cover" src="/img/go.png" onerror="onerror=null;src='/img/404.png'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">整合sql和sqlx</div></div><div class="info-2"><div class="info-item-1">整合sql和sqlxWhat is sqlx sqlx是Go语言内置database/sql的超集，它在优秀的内置database/sql基础上提供了一组扩展  Get sqlx go get github.com/jmoiron/sqlx  Prepare sqlx1234567891011121314151617181920212223242526272829package mysqlimport (	&quot;bluebell/setting&quot;	&quot;fmt&quot;	_ &quot;github.com/go-sql-driver/mysql&quot;	&quot;github.com/jmoiron/sqlx&quot;)var db *sqlx.DB// Init 初始化MySQL连接func Init(cfg *setting.MySQLConfig) (err error) &#123;	// &quot;user:password@tcp(host:port)/dbname&quot;	dsn := fmt.Sprintf(&quot;%s...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/08/20/web/go/Gorm-%E9%92%A9%E5%AD%90Hook/" title="Gin中间件"><img class="cover" src="/img/go.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-20</div><div class="info-item-2">Gin中间件</div></div><div class="info-2"><div class="info-item-1">Gorm：钩子HookHook 是在创建、查询、更新、删除等操作之前、之后调用的函数。 支持以下的Hook方法 1234567891011121314151617181920212223242526272829303132333435type BeforeCreateInterface interface &#123;    BeforeCreate(*gorm.DB) error&#125;type AfterCreateInterface interface &#123;    AfterCreate(*gorm.DB) error&#125;type BeforeUpdateInterface interface &#123;    BeforeUpdate(*gorm.DB) error&#125;type AfterUpdateInterface interface &#123;    AfterUpdate(*gorm.DB) error&#125;type BeforeSaveInterface interface &#123;    BeforeSave(*gor...</div></div></div></a><a class="pagination-related" href="/2024/07/23/basic/go/Go-%E6%A0%87%E5%87%86%E5%BA%93%E6%97%A5%E5%BF%97Slog/" title="Go-标准库日志Slog"><img class="cover" src="/img/go.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-23</div><div class="info-item-2">Go-标准库日志Slog</div></div><div class="info-2"><div class="info-item-1">Go的标准库日志Slog背景在Go1.21中，在Go的标准库函数中引入了Slog 据说使用的内存比Zap还要小 基础用法12345678slog.Info(&quot;This is info log&quot;)slog.Warn(&quot;This is warning log&quot;)slog.Error(&quot;This is error log&quot;)日志输出：2024/07/23 15:26:01 INFO This is info log2024/07/23 15:26:01 WARN This is warning log2024/07/23 15:26:01 ERROR This is error log  输出参数的日志12345678	name := &quot;sss&quot;	slog.Info(&quot;msg&quot;, slog.String(&quot;name&quot;, name))	slog.Error(&quot;ERROR: value is empty&quot;, slog.Any(&quot;name&qu...</div></div></div></a><a class="pagination-related" href="/2024/03/31/basic/go/Go-%E6%8E%A7%E5%88%B6%E5%8D%8F%E7%A8%8B%E6%95%B0%E9%87%8F/" title="Go-控制协程数量"><img class="cover" src="/img/go.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-31</div><div class="info-item-2">Go-控制协程数量</div></div><div class="info-2"><div class="info-item-1">Go-控制协程数量背景GMP的无限创建Goroutine基于共享用户态资源，过多的协程会导致CPU利用率浮动上涨、内存占用上涨、主进程崩溃 如何控制Goroutine数量基于buffer的channel原理：通过buffer的缓冲区的大小和阻塞等待来控制最大的数量 1234567891011121314151617181920212223242526package mainimport (	&quot;fmt&quot;	&quot;runtime&quot;	&quot;time&quot;)func doGoroutine(i int, ch chan bool) &#123;	fmt.Println(&quot;go func&quot;, i, &quot;goroutine count&quot;, runtime.NumGoroutine())	// 结束了一个任务	&lt;-ch&#125;func main() &#123;	task_cnt := 10	// 容量控制了 Goroutine 的数量	ch := make(chan bool, 3)	// for的...</div></div></div></a><a class="pagination-related" href="/2024/03/30/web/distributed/%E5%88%86%E5%B8%83%E5%BC%8F-CAP%E7%90%86%E8%AE%BA/" title="分布式-CAP理论"><img class="cover" src="/img/go.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-30</div><div class="info-item-2">分布式-CAP理论</div></div><div class="info-2"><div class="info-item-1">分布式-CAP理论背景在大规模拓展服务下存在三个特性：  C（Consistency）：一致性  A（Availability）：可用性  D（Partition Tolerance）：分区容错性    一致性一致性： All nodes see the same data at the same time 所有节点数据，在同一时刻，读数据都是最新的  流程：  对主存储写数据  进行上锁，要求对从存储进行同步  同步成功，释放锁，返回成功   可用性可用性：Reads and writes always succeed 服务永远可用，用户感知不到异常  流程：  用户向master请求  master从从存储请求   分区容错性分区容错性：The system continues to operate despite arbitrary message loss or failure of part of the system 在分布式系统中，尽管部分节点出现任何消息丢失或者故障，系统还应继续运⾏   流程： 尽使⽤异步取代同步操作，例如使⽤异步⽅式将数据从主数据库同步到从数据...</div></div></div></a><a class="pagination-related" href="/2024/03/30/web/distributed/%E5%88%86%E5%B8%83%E5%BC%8F-Base%E7%90%86%E8%AE%BA/" title="分布式-Base理论"><img class="cover" src="/img/go.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-30</div><div class="info-item-2">分布式-Base理论</div></div><div class="info-2"><div class="info-item-1">分布式-Base理论介绍CAP无法同时满足，为了同时实现CAP系统，所以出现了BASE  BA（Basically Available）：基本 可用  S(Soft State)：软状态  E（Eventually Consistent）：最终一致性   ACID和BASE是对冲理论：  ACID追求强一制性  BASE牺牲强一致性，追求高可用性   Basically Available 通过妥协响应时间和功能损失 场景:  断电，增大响应时间  高并发下，电商提示抢购失败   Soft State软状态本质就是系统中的数据有中间状态，多节点的副本数据等待同步数据延迟 Eventually Consistent软状态数据不可以一直持续，必须在一段时间内完成同步，达到最终一致性 </div></div></div></a><a class="pagination-related" href="/2024/03/30/web/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%20id%20%E7%94%9F%E6%88%90%E5%99%A8/" title="分布式 id 生成器（snowflake，雪花算法）"><img class="cover" src="/img/go.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-30</div><div class="info-item-2">分布式 id 生成器（snowflake，雪花算法）</div></div><div class="info-2"><div class="info-item-1">分布式 id 生成器（snowflake，雪花算法）背景在某些场景下，需要生成增长ID并且不能重复 snowflakeSnowflake 雪花算法，由Twitter提出并开源，可在分布式环境下用于生成唯一ID的算法。该算法生成的是一个64位的ID，故在Java下正好可以通过8字节的long类型存放。所生成的ID结构如下所示  1 bit：首位无效因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。 41 bit：表示的是时间戳，单位是毫秒41 bit 可以表示的数字多达 2^41 - 1，也就是可以标识 2 ^ 41 - 1 个毫秒值，换算成年就是表示 69 年的时间。 10 bit：记录工作机器 id，代表的是这个服务最多可以部署在 2^10 台机器上，也就是 1024 台机器10 bit 里 5 个 bit 代表机房 id，5 个 bit 代表机器 id。意思就是最多代表 2 ^ 5 个机房（32 个机房），每个机房里可以代表 2 ^ 5 个机器（32 台机器），也可以根据自己公司的实际情况确定。 12 b...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Joohwan.</div><div class="author-info-description">该知道的都知道，不知道的慢慢了解</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">245</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">59</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/piwriw"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/piwriw" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:piwriw@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget"><div class="item-headline"><i class="iconfont icat-visitor"></i><span>来访者</span></div><div class="item-content"><div id="welcome-info"></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B4%E5%90%88%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5"><span class="toc-number">1.</span> <span class="toc-text">整合限流策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E6%B5%81"><span class="toc-number">1.1.</span> <span class="toc-text">限流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.</span> <span class="toc-text">常用的限流策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%A1%B6%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">漏桶法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#uber-go-ratelimit%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">uber-go&#x2F;ratelimit实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Example-uber-go-ratelimit"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">Example uber-go&#x2F;ratelimit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">令牌桶算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#github-com-juju-ratelimit-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">github.com&#x2F;juju&#x2F;ratelimit 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Example-github-com-juju-ratelimit"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">Example github.com&#x2F;juju&#x2F;ratelimit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3"><span class="toc-number">1.2.3.</span> <span class="toc-text">固定窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.2.4.</span> <span class="toc-text">滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gin%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">gin框架中使用限流中间件</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/24/cloud/k8s/K8s%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E5%AE%A2%E6%88%B7%E7%AB%AF/" title="K8s开发指南-客户端"><img src="/img/k8sLogo.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="K8s开发指南-客户端"/></a><div class="content"><a class="title" href="/2025/08/24/cloud/k8s/K8s%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E5%AE%A2%E6%88%B7%E7%AB%AF/" title="K8s开发指南-客户端">K8s开发指南-客户端</a><time datetime="2025-08-24T04:57:55.000Z" title="发表于 2025-08-24 12:57:55">2025-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/23/cloud/k8s/K8s%E5%BC%80%E5%8F%91-API%E8%AF%A6%E8%A7%A3/" title="K8s开发-API详解"><img src="/img/k8sLogo.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="K8s开发-API详解"/></a><div class="content"><a class="title" href="/2025/08/23/cloud/k8s/K8s%E5%BC%80%E5%8F%91-API%E8%AF%A6%E8%A7%A3/" title="K8s开发-API详解">K8s开发-API详解</a><time datetime="2025-08-23T04:57:55.000Z" title="发表于 2025-08-23 12:57:55">2025-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/22/cloud/k8s/K8s%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6-%E6%8B%93%E5%B1%95%E8%AE%A4%E8%AF%81/" title="K8s认证机制-拓展认证"><img src="/img/k8sLogo.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="K8s认证机制-拓展认证"/></a><div class="content"><a class="title" href="/2025/08/22/cloud/k8s/K8s%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6-%E6%8B%93%E5%B1%95%E8%AE%A4%E8%AF%81/" title="K8s认证机制-拓展认证">K8s认证机制-拓展认证</a><time datetime="2025-08-22T04:57:55.000Z" title="发表于 2025-08-22 12:57:55">2025-08-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/26/cloud/prometheus/Prometheus-Rules%E5%91%8A%E8%AD%A6%E8%AF%84%E4%BC%B0/" title="Prometheus-Rules告警评估"><img src="/img/prometheus.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="Prometheus-Rules告警评估"/></a><div class="content"><a class="title" href="/2025/07/26/cloud/prometheus/Prometheus-Rules%E5%91%8A%E8%AD%A6%E8%AF%84%E4%BC%B0/" title="Prometheus-Rules告警评估">Prometheus-Rules告警评估</a><time datetime="2025-07-26T14:08:55.000Z" title="发表于 2025-07-26 22:08:55">2025-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/25/cloud/prometheus/Prometheus-Srape%E6%8C%87%E6%A0%87%E6%8A%93%E5%8F%96/" title="Prometheus-Scrape指标抓取"><img src="/img/prometheus.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="Prometheus-Scrape指标抓取"/></a><div class="content"><a class="title" href="/2025/07/25/cloud/prometheus/Prometheus-Srape%E6%8C%87%E6%A0%87%E6%8A%93%E5%8F%96/" title="Prometheus-Scrape指标抓取">Prometheus-Scrape指标抓取</a><time datetime="2025-07-25T14:08:55.000Z" title="发表于 2025-07-25 22:08:55">2025-07-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By Joohwan.</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://piwriw-twikoo-git-main-piwriw.vercel.app/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://piwriw-twikoo-git-main-piwriw.vercel.app/',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start -->
  <script data-pjax src="undefined"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="undefined?piwriw";
            var git_color =undefined;
            var git_user ="piwriw";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px; display: flex; align-items: center; justify-content: center;"> <img src="https://ghchart.rshah.org/piwriw" alt="piwriw" style="width: 100%; height: auto; max-width: 100%;"> </div> ';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:undefined}@media screen and (max-width:650px) {#github_container{background-image:;min-height:undefined}}</style>
    <style>undefined</style><!-- hexo injector body_end end --></body></html>